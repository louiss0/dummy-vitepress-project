import path from 'node:path';
import { normalizePath } from 'vite';
import fs from 'node:fs';
import { createRequire } from 'node:module';
import { parseVueRequest as parseVueRequest$1 } from '@vitejs/plugin-vue';
import { c as capitalize, a as camelize } from './shared/vite-plugin-vue-nested-sfc.ea4708ce.mjs';

function resolveCompiler(root) {
  const compiler = tryResolveCompiler(root) || tryResolveCompiler();
  if (!compiler) {
    throw new Error(
      `Failed to resolve vue/compiler-sfc.
@vitejs/plugin-vue requires vue (>=3.2.25) to be present in the dependency tree.`
    );
  }
  return compiler;
}
function tryResolveCompiler(root) {
  const vueMeta = tryRequire("vue/package.json", root);
  if (vueMeta && vueMeta.version.split(".")[0] >= 3) {
    return tryRequire("vue/compiler-sfc", root);
  }
}
const _require = createRequire(import.meta.url);
function tryRequire(id, from) {
  try {
    return from ? _require(_require.resolve(id, { paths: [from] })) : _require(id);
  } catch {
  }
}

function createCache(config) {
  const descriptorCache = /* @__PURE__ */ new Map();
  const nestedComponentNames = /* @__PURE__ */ new Set();
  const compiler = resolveCompiler(config.root);
  return {
    getDescriptor(filename) {
      if (!descriptorCache.has(filename)) {
        const { descriptor, errors } = compiler.parse(
          fs.readFileSync(filename, "utf8").toString(),
          {
            filename,
            sourceMap: config.command === "build" ? !!config.build.sourcemap : true,
            sourceRoot: config.root
          }
        );
        if (errors.length > 0) {
          throw errors[0];
        }
        descriptorCache.set(filename, descriptor);
      }
      return descriptorCache.get(filename);
    },
    updateFileCache(filename, code) {
      const { descriptor, errors } = compiler.parse(code, { filename });
      if (errors.length > 0) {
        throw errors[0];
      }
      descriptorCache.set(filename, descriptor);
    },
    hasFile(filename) {
      return descriptorCache.has(filename);
    },
    registerNestedComponent(filename, component) {
      if (filename.startsWith(config.root)) {
        filename = filename.slice(config.root.length);
      }
      nestedComponentNames.add(`${filename}/${component}.vue`);
    },
    isNestedComponent(filename) {
      if (filename.startsWith(config.root)) {
        filename = filename.slice(config.root.length);
      }
      return nestedComponentNames.has(filename);
    }
  };
}

function genComponentBlockCode(filename, component) {
  return `import ${component} from '${filename}/${component}.vue';
export default function(Comp) {
  if (!Comp.components) {
    Comp.components = {};
  }
  Comp.components[${JSON.stringify(component)}] = ${component};
}`;
}
function genExportsCode(filename, components, mainCode) {
  const codes = [mainCode, "\n"];
  for (const component of components) {
    codes.push(
      "export { default as ",
      component,
      " } from '",
      filename,
      "/",
      component,
      ".vue';\n"
    );
  }
  return codes.join("");
}

function pascalCase(str) {
  return capitalize(camelize(str));
}
function parseVueRequest(id) {
  return parseVueRequest$1(id);
}

function vueNestedSFC() {
  let config;
  let cache;
  return {
    name: "vite:vue-nested-sfc",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
    },
    buildStart() {
      cache = createCache(config);
    },
    resolveId(id, importerFile) {
      if (cache.isNestedComponent(id)) {
        return id;
      }
      const request = importerFile && parseVueRequest(importerFile);
      if (request && cache.isNestedComponent(request.filename)) {
        let [, importerDir] = request.filename.match(
          /^(.*)(?:\/[^/]+){2}\.vue$/
        );
        if (!importerDir.startsWith(config.root)) {
          importerDir = config.root + importerDir;
        }
        return normalizePath(path.resolve(importerDir, id));
      }
    },
    load(id) {
      if (!cache.isNestedComponent(id)) {
        return;
      }
      const match = id.match(/^(.*)\/([^/]+)\.vue$/);
      if (!match) {
        return;
      }
      let filename = match[1];
      const component = match[2];
      if (!filename.startsWith(config.root)) {
        filename = config.root + filename;
      }
      const descriptor = cache.getDescriptor(filename);
      const componentBlock = descriptor.customBlocks.find(
        (block) => block.type === "component" && typeof block.attrs.name === "string" && pascalCase(block.attrs.name) === component
      );
      if (!componentBlock) {
        return "";
      }
      return { code: componentBlock.content, map: componentBlock.map };
    },
    transform(code, id) {
      const request = parseVueRequest(id);
      if (cache.isNestedComponent(id)) {
        return;
      }
      if (!request.query.vue && request.filename.endsWith(".vue")) {
        const exportedComponents = cache.getDescriptor(request.filename).customBlocks.filter(
          (block) => block.type === "component" && typeof block.attrs.name === "string" && !!block.attrs.export
        ).map((block) => pascalCase(block.attrs.name));
        if (exportedComponents.length === 0) {
          return;
        }
        for (const componentName of exportedComponents) {
          cache.registerNestedComponent(request.filename, componentName);
        }
        return {
          code: genExportsCode(request.filename, exportedComponents, code),
          map: null
        };
      } else if (request.query.type === "component") {
        if (typeof request.query.name !== "string") {
          throw new TypeError("Component blocks require a name attribute.");
        }
        const componentName = pascalCase(request.query.name);
        cache.registerNestedComponent(request.filename, componentName);
        return {
          code: genComponentBlockCode(request.filename, componentName),
          map: { mappings: "" }
        };
      }
    },
    async handleHotUpdate({ modules, read, file, server }) {
      if (!cache.hasFile(file)) {
        return modules;
      }
      const affectedModules = new Set(
        modules.filter((m) => !/type=component/.test(m.url))
      );
      const prevDescriptor = cache.getDescriptor(file);
      cache.updateFileCache(file, await read());
      const nextDescriptor = cache.getDescriptor(file);
      const mainModule = server.moduleGraph.getModuleById(file);
      if (prevDescriptor.customBlocks.length !== nextDescriptor.customBlocks.length) {
        if (mainModule) {
          affectedModules.add(mainModule);
        }
      }
      for (const block of prevDescriptor.customBlocks) {
        if (block.type !== "component") {
          continue;
        }
        if (typeof block.attrs.name !== "string") {
          if (mainModule) {
            affectedModules.add(mainModule);
          }
          continue;
        }
        const name = pascalCase(block.attrs.name);
        const nextBlock = nextDescriptor.customBlocks.find(
          (nextBlock2) => nextBlock2.type === "component" && typeof nextBlock2.attrs.name === "string" && pascalCase(nextBlock2.attrs.name) === name
        );
        if (!nextBlock || nextBlock.attrs.name !== block.attrs.name || nextBlock.attrs.export !== block.attrs.export) {
          if (mainModule) {
            affectedModules.add(mainModule);
          }
        }
        if (!nextBlock || block.content === nextBlock.content) {
          continue;
        }
        const componentModule = server.moduleGraph.getModuleById(`${file}/${name}.vue`) || server.moduleGraph.getModuleById(
          `${file.replace(config.root, "")}/${name}.vue`
        );
        if (!componentModule) {
          continue;
        }
        affectedModules.add(componentModule);
        const blockModule = [...componentModule.importers].find(
          (m) => m.url.includes("type=component") && m.url.includes(`name=${nextBlock.attrs.name}`)
        );
        if (blockModule) {
          affectedModules.add(blockModule);
        }
        const subModules = [...componentModule.importedModules].filter(
          (m) => m.url.startsWith(componentModule.url)
        );
        for (const subModule of subModules) {
          affectedModules.add(subModule);
        }
      }
      return [...affectedModules];
    }
  };
}

export { vueNestedSFC as default };
